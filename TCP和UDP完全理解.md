# 1 tcp
## 1.1 tcp特点
* 面向连接
* 基于字节流
* 提供可靠的数据交付
### 1.1.1 什么是面向连接
通信前双方要先建立连接。双方系统要分配资源管理连接的状态和数据的收发。
### 1.1.2 什么是基于字节流
数据的收发是没有边界的。
应用发送方的写操作次数跟应用接收方的读次数没有必然的联系。原因在于应用发送方调用写操作后，内核会把发送的数据存放到内核缓冲区中，直到TCP模块发送数据时，会把这些数据分成一个或者多个TCP报文段发送出去。同理，接收方收到多个TCP报文段时会把它们先存放在内核缓冲区中，然后通知应用来读取。应用可以一次读完，也可以分多次读完。具体取决于应用接收方的缓冲区大小。

### 1.1.3 tcp如何保证提供可靠的数据交付
* 发送确认。每个发送出去的TCP报文，都必须周到对方的确认报文后才认为已经成功传输。
* 超时重传。对每个发送出去的TCP报文，TCP会启动一个定时器。如果在规定时间内没有收到确认报文，则会认为该包丢失，并对它进行重传。
* 差错检验。TCP会利用TCP头部中的16位校验字段，对收到的TCP报文的头部和内容进行校验。
* 滑动窗口。滑动窗口是基于发送确认和超时重传机制实现。滑动窗口的目的是为了进行流控制，避免发送方发送速度过快导致接收方被淹没。
* 流量控制。拥塞控制的目的是避免TCP将过多的数据注入到网络中，导致路由器或者链路节点过载，使网络性能急剧下降。流量控制的算法有慢启动、拥塞避免、快恢复、快重传。
### 1.1.4 拥塞控制算法详解
拥塞控制算法有四种：慢启动、拥塞避免、快恢复、快重传。发送方会维持一个拥塞窗口cwnd，窗口大小根据网络拥塞情况动态变化。同时让自己的发送窗口等于拥塞窗口。
* 慢启动。TCP连接刚建立时，cwnd=1，每经过一个RTT，cwnd=2\*cwnd，拥塞窗口指数增长。
* 拥塞避免。当cwnd大于拥塞阈值ssthreadshold时，每经过一个RTT，cwnd=cwnd+1，拥塞窗口线性增长。
  如果没有使用快重传、快恢复算法，那么当发生拥塞后，把拥塞阈值ssthreadshold减半，同时设置cwnd=1，执行慢启动+拥塞避免来增长拥塞窗口。
  网络是否发生拥塞的判断依据时是否收到确认。
* 快重传+加快启动。当发送方连续收到三个重复确认，不管超时定时器有没有到期，立即把慢启动的拥塞阈值减半，然后按拥塞避免算法增长cwnd。


## 1.2  tcp缺点
* 速度慢
* 占用系统资源多
* 易受攻击
## 1.3 tcp粘包问题
## 1.4 tcp面试常问
* 三次握手和四次挥手过程
* 为啥握手只要三次，挥手要四次
* TIMEWAIT状态存在的原因
* listen里的backlog参数有什么含义
* set_sockopt有哪些选项，都有什么含义
* tcp的保活机制
* socket什么时候可读，什么时候可写
* 什么时候会收到RST
### 1.4.1 什么时候会收到RST
RST表示异常连接。发送发发送RST时，不用管发送缓冲区中的数据是否已经发送完成，会将发送缓冲区数据丢弃直接发送RST。而接收方收到RST时，不用恢复ACK。
收到RST的有如下几种情况：
* 去连接为打开的端口。例如，telnet未打开的端口就会收到RST。
* 请求建立连接超时。在设置SO_RCVTIMEO后，如果发送出去SYN包后在规定时间内没法收到ACK+SYN包，发送方会发送RST给接收端。
* 提前关闭连接。提前指接收方未完全读取缓冲区的数据就关闭连接，这时候接收方会给发送方发送RST。
* 向已经关闭的端口发送数据或者读取数据都会收到RST。

### 1.4.2 listen的backlog参数有什么含义
listen的backlog指socket的排队连接数。数量大小等于半完成连接队列的连接数+已完成连接队列的连接数之和。

### 1.4.3 tcp的保活机制
tcp的保活机制是为了维持tcp的长连接机制。在7200秒内，如果tcp没有进行任何操作，tcp会发送一个心跳包来探测对端是否存活。如果对端没有响应，那么在隔72秒后，TCP 会再发送探测包。总共发送10次。如果都没有回应，就会认为这个对端已经挂了，从而关闭这个连接。
TCP保活机制的探测时间太长，一般都会再用户层进行双向的ping包作为TCP保活的补充。
我们可以通过SO_KEEPALIVE选项来打开tcp的保活机制。

### 1.4.4 TIMEWAIT状态存在的原因
为了可靠的关闭连接。如果最后一个ACK包丢失，TIMEWAIT状态内会重发ACK包，这样子就可以可靠的关闭连接了。
我们可以通过SO_REUSEDADDR来快速回收处于TIMEWAIT状态的连接。

### 1.4.5 set_sockopt有哪些选项，都有什么含义
SO_RCVBUF,SO_SNDBUF用来设置TCP收发缓冲区的大小。
SO_RCVTIMTO,SO_SNDTIMEO用来设置TCP收发的超时时间。
SO_RCVLOWWAT,SO_SNDLOWWAT用来设置TCP读写缓冲区的触发值。
SO_LINGER用来设置close的行为。
# 2 udp
## 2.1 udp特点
* 无连接
* 面向数据报
* 无序不可靠
### 2.1.1 什么是面向数据报
数据收发是有边界的。发送方按几次发送，接收方就要按几次接收。
应用方交给UDP多长的报文，UDP既不拆分，也不合并，只会把他们全部一次向下传递给IP层发送出去。如果UDP交给IP层的数据报太长，IP层会自己分片发送出去然后再组片。
### 2.1.2 发送方按顺序发送了1、2、3三个数据报出去，那么接收方有可能接收到的报文顺序是什么
按照UDP的无序性，接收方有可能收到的是123，也有可能是321，总是是1、2、3的任意组合。
同时按照UDP的不可靠性，接收方有可能接受不1或者2、或者3或者都接收不到。
### 2.1.3 发送方第一次sendto了500字节，第二次sendto了300字节，接收方用recvfrom(1000)，有可能收到什么？如果接收方recvfrom(200)，又有可能收到什么？假定两次发送都能按顺序到达，接收方分别调用recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，又有可能收到什么？如果MTU是1500，UDP一次发送8000个字节出去，接收方recvfrom(9000)，接收方可能收到多少？
因为UDP的无序性，只调用recvfrom(1000)可能得到的300，也有可能得到的是500。又因为UDP的不可靠性，也有可能啥都收不到。
同理，只调用recvfrom(200)，有可能收到200，也有可能啥都收不到。
如果分三次调用recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，又可能第一次收到200，然后丢弃300字节，然后第二次收到300，然后最后一次阻塞。
不管MTU如何，一次发送8000个字节出去，接收方recvfrom(9000)，接收可能收到的只是8000或者没有收到。在UDP缓存足够大的情况，UDP会一次把8000字节的包发送出去。IP层会负责分片和组片，IP层提交给UDP的一定是一个8000字节的包。在组片时如果有的IP分片丢失，UDP会进行校验，那么UDP就会把收到的包丢弃，这个时候UDP就啥也收不到。

## 2.2 udp缺点
* 无序不可靠
## 2.3 理想的UDP数据包大小
UDP包头的数据报长度字段有16位，表明UDP数据包最长可以为64k。但是数据链路层的MTU为1500，UDP交付给IP层的数据包大于1500时，IP层会进行分片，这会增加UDP的丢包风险。
因特网标准MTU值为576,因此最好将UDP包控制在(576-20-8)个字节内。
## 2.4 udp丢包问题
### 2.4.1 udp丢包原因
* 接收缓冲区已满。接收缓冲区满后，如果应用不及时读取缓冲区中的数据，后续到达的包会被UDP丢弃。在程序上表现就是调用recvfrom的接口处理数据话费时间太久。解决方法1.数据的接收和处理分开进行。开辟一个单独的用户缓冲区，用独立的线程调用recvfrom把数据从UDP接收缓冲区中读出来，然后再做进一步处理。2.增加缓冲区大小。但是服务已经过载的情况下，增加缓冲区效果不大。
* 接收缓冲区太小。如果发送过来UDP报文比接收缓冲区还大，该包会被丢弃。
* 接收端ARP缓存失效。ARP缓存有效时间10分钟，失效后后发起ARP请求去获取对方mac。这个期间client发送过来的UDP数据报会被缓存一定的个数，其它的会被丢弃。
* 发送报文过大。发送报文过大，IP层的分片就越多。一旦一个分片丢失，整个包都会被丢弃。此外发送报文过大对对方接收缓冲区也有要求。
* 发送方发送频率过快。sendto不能保证数据完全发送出去。频率过快会导致内部缓冲区满，然后那个瞬间的包会丢失。解决方法就是sleep。

## 2.5 UDP丢包解决方法
### 2.5.1 冗余传输
一般最常用的方法就是延时双发。即将前后连续的两个包合并成一个发送。这样数据量增加了一杯，但是可以通过其它数据的包恢复出完整的数据。
## 2.6 UDP的应用场合
* 实时性要求高的场合。例如实时语音视频。
* 不便采用TCP进行多点传输的场合。例如实时多人语音通信。
* 要求NAT穿越。UDP的无连接特性会使NAT成功率极高。
## 2.7 面试常问
* UDP可以使用connect吗？

### 2.7.1 UDP可以使用connect吗？这样做有什么好处？
UDP可以使用connect的方式，这样做有两个好处：
* 较少内存开销。如果不用connect的方式，每次sendto都会把对端的信息从用户空间拷贝到内核空间中，然后在内核分配空间保存对端的信息。sendto结束后，又要释放调这些空间。如果进行connect，内核会一直维护一个保存对端的信息数据结构，每次send或者sendto不需要重新分配或者释放该数据结构，从而避免了拷贝、建立、释放的开销，提升效率。
* 感知到socket的错误消息。

